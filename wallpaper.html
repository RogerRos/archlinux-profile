<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Universo Dinámico Abstracto</title>
  <style>
    html,body{
      margin:0;
      height:100%;
      background:#04070d;
      overflow:hidden;
    }
    canvas{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }
  </style>
</head>
<body>
  <canvas id="wgl"></canvas>

  <script>
  ;(() => {
    const canvas = document.getElementById('wgl');

    let gl = null;
    let prog = null;
    let buf = null;
    let rafId = null;
    let startMs = 0;
    let lastMs = 0;

    const MAX_DPR = 1.5;
    const TIME_WRAP = 600.0;

    let locP = null;
    let uRes = null;
    let uTime = null;
    let currentDPR = 1;

    function compile(gl, type, src){
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        const info = gl.getShaderInfoLog(s) || 'Error de compilación';
        gl.deleteShader(s);
        throw new Error(info);
      }
      return s;
    }

    function createProgram(gl, vsSrc, fsSrc){
      const vs = compile(gl, gl.VERTEX_SHADER, vsSrc);
      const fs = compile(gl, gl.FRAGMENT_SHADER, fsSrc);
      const p = gl.createProgram();
      gl.attachShader(p, vs);
      gl.attachShader(p, fs);
      gl.linkProgram(p);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
        const info = gl.getProgramInfoLog(p) || 'Error de enlace';
        gl.deleteProgram(p);
        throw new Error(info);
      }
      return p;
    }

    const VS = `
      attribute vec2 p;
      void main(){ gl_Position = vec4(p, 0.0, 1.0); }
    `;

    const FS = `
      #ifdef GL_ES
        #ifdef GL_FRAGMENT_PRECISION_HIGH
          precision highp float;
        #else
          precision mediump float;
        #endif
      #else
        precision highp float;
      #endif

      uniform vec2 u_res;
      uniform float u_time;

      float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
      float noise(vec2 p){
        vec2 i=floor(p),f=fract(p);
        float a=hash(i),b=hash(i+vec2(1.0,0.0)),c=hash(i+vec2(0.0,1.0)),d=hash(i+vec2(1.0,1.0));
        vec2 u=f*f*(3.0-2.0*f);
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
      }
      float fbm(vec2 p){
        float v=0.0, a=0.5;
        mat2 m = mat2(1.6,1.2,-1.2,1.6);
        for(int i=0;i<6;i++){ v += a*noise(p); p = m*p; a *= 0.5; }
        return v;
      }
      vec2 curl(vec2 p){
        float e=0.05;
        float n1=fbm(p+vec2(0.0,e));
        float n2=fbm(p-vec2(0.0,e));
        float n3=fbm(p+vec2(e,0.0));
        float n4=fbm(p-vec2(e,0.0));
        return vec2((n1-n2),-(n3-n4));
      }

      void main(){
        vec2 uv = gl_FragCoord.xy / u_res;
        vec2 p = (uv - 0.5) * 2.0;
        p.x *= u_res.x / u_res.y;
        float t = u_time * 0.25;

        vec2 centers[6];
        centers[0]=vec2(sin(t*0.2)*0.9,  cos(t*0.3)*0.7);
        centers[1]=vec2(sin(t*0.25+2.1)*0.7, cos(t*0.21+1.2)*0.9);
        centers[2]=vec2(sin(t*0.27-1.3)*0.8, cos(t*0.22-2.0)*0.6);
        centers[3]=vec2(sin(t*0.18+0.7)*1.1, cos(t*0.26+1.5)*0.8);
        centers[4]=vec2(sin(t*0.23-0.9)*0.6, cos(t*0.19+2.1)*1.0);
        centers[5]=vec2(sin(t*0.28+1.9)*1.0, cos(t*0.17-1.3)*0.9);

        float grav = 0.0;
        for(int i=0;i<6;i++){
          float d = length(p - centers[i]);
          grav += exp(-d*2.2);
        }
        grav /= 6.0;

        vec2 q=p;
        q+=0.25*curl(p*1.2+t*0.4);
        q+=0.15*curl(p*3.0 - t*0.2);
        q+=0.10*vec2(sin(t*0.6+p.y*1.2),cos(t*0.5+p.x*1.3))*grav;

        float base=fbm(q*2.0+t*0.5);
        float detail=fbm(q*4.0-t*0.3);
        float field=(base*0.6+detail*0.4)*1.2;

        float cond = smoothstep(0.45,0.75,field+0.25*grav);
        float collapse = exp(-abs(field-grav)*6.0);

        float density = mix(cond,collapse,0.6);
        float pulse = sin(t*0.5 + fbm(p*3.0))*0.5+0.5;
        density = mix(density,fbm(p*3.5 - t*0.3),pulse*0.3);
        density = pow(density,1.6);

        vec3 baseColor = vec3(0.03,0.05,0.10);
        vec3 glowColor = vec3(0.0,0.55,0.8);
        vec3 col = mix(baseColor, glowColor, density);
        col += 0.3*vec3(0.0,0.9,1.0)*collapse;
        col = pow(col,vec3(0.9));

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function getSafeDPR(){
      const dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);
      return Math.max(1, Math.round(dpr * 100) / 100);
    }

    function fit(){
      const dpr = getSafeDPR();
      if (dpr !== currentDPR) currentDPR = dpr;

      const w = Math.max(1, Math.floor(innerWidth * currentDPR));
      const h = Math.max(1, Math.floor(innerHeight * currentDPR));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
        if (gl) gl.viewport(0, 0, w, h);
      }
    }

    function initGL(){
      gl = canvas.getContext('webgl2', { antialias:false, alpha:true, powerPreference:'high-performance', preserveDrawingBuffer:false })
        || canvas.getContext('webgl', { antialias:false, alpha:true, powerPreference:'high-performance', preserveDrawingBuffer:false });
      if(!gl){
        console.error('WebGL no disponible');
        return false;
      }

      canvas.addEventListener('webglcontextlost', onContextLost, { passive:false });
      canvas.addEventListener('webglcontextrestored', onContextRestored, { passive:true });

      try{
        prog = createProgram(gl, VS, FS);
      }catch(err){
        console.error('Shader error:', err);
        return false;
      }

      gl.useProgram(prog);

      buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);

      locP = gl.getAttribLocation(prog, 'p');
      gl.enableVertexAttribArray(locP);
      gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

      uRes = gl.getUniformLocation(prog, 'u_res');
      uTime = gl.getUniformLocation(prog, 'u_time');

      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.BLEND);
      gl.disable(gl.CULL_FACE);

      fit();
      return true;
    }

    function destroyGL(){
      if (!gl) return;
      if (rafId != null){ cancelAnimationFrame(rafId); rafId = null; }
      if (prog){ gl.deleteProgram(prog); prog = null; }
      if (buf){ gl.deleteBuffer(buf); buf = null; }
      gl = null;
    }

    function onContextLost(e){
      e.preventDefault();
      if (rafId != null){ cancelAnimationFrame(rafId); rafId = null; }
    }

    function onContextRestored(){
      destroyGL();
      if (initGL()) {
        startMs = performance.now();
        lastMs = startMs;
        loop(performance.now());
      } else {
        console.error('No se pudo restaurar WebGL');
      }
    }

    function loop(nowMs){
      rafId = requestAnimationFrame(loop);

      fit();

      const dt = Math.max(0, Math.min(0.1, (nowMs - lastMs) * 0.001));
      lastMs = nowMs;

      const tWrapped = ((nowMs - startMs) * 0.001) % TIME_WRAP;

      if (!gl || !prog) return;

      gl.useProgram(prog);
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.uniform1f(uTime, tWrapped);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

    let resizeTimer = null;
    addEventListener('resize', () => {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        resizeTimer = null;
        fit();
      }, 100);
    }, { passive:true });

    if (initGL()){
      startMs = performance.now();
      lastMs = startMs;
      loop(performance.now());
    }
  })();
  </script>
</body>
</html>
